---
sidebar_position: 1
---

# What is Cp1?

Cp1 or C+1 or C plus 1 is a programming language that aims to **simplify C programming** and also to give C some advancements. Cp1 is **for people who likes C** but needs few modern features such as metaprogramming, methods, namespaces, auto variable type deduction and more.

## üëã Hello World
```cpone
require "LibCp1/stdout.cp1";
using C1 = LibCp1;
main():intc { // A function declaration
   C1.stdout{"Hello world\n"}
   return 0;
}
```
## üñãÔ∏è Easy-to-use Yet Powerful Metaprogramming System
```cpone
// Let's create a metaprogram
meta #MakeAFunction {
   using C1 = LibCp1;
   ${arg.name}() { // A function declaration
      C1.stdout{"${arg.message}\n"}
   }
}
// Use the metaprogram we created above
#MakeAFunction{name:"Greet",message:"Hello World"}
#MakeAFunction{name:"AskName",message:"What's your name?"}
#MakeAFunction{name:"AskAge",message:"How old are you?"}
```
- Metaprogramming is as **easy as string interpolation**. Powered by QuickJS of **Fabrice Bellard**, the creator of TCC. Based on simple repeated hello world benchmark, QuickJS is slightly **faster than Lua**.
- Metaprograms are **cached** and can have few or **zero overhead**. If metaprograms are unmodified, the compiler uses the cache folder and codes are **compiled just as fast as regular codes**. In contrast to others, most metaprogramming systems do not cache their codes and are always computed in compile time.
- **Debugging is easier** than other metaprogramming systems (e.g. C++ templates). You have the ability to **see the actual codes** generated by metaprograms in the cache folder and find where the bugs are.

## üó≤ Fast Compilation Speeds

- Built with **incremental compilation** in mind. Up to **125K lines of codes per second** on a single-core compilation and can utilize use **multiple cores** on more advanced usage of Cp1.
- Files that are not modified are **cached and never parsed again**.
- Cp1 can compile itself in **0.1 seconds** on using TCC.

*\* Speeds are based on Macbook M2 running Fedora Asahi Remix.*

## üîçShorter And More Readable Codes
```cpone
require "LibCp1/stdout.cp1";
using C1 = LibCp1;
struct Dog[] {
   sit(dog:this) {
      C1.stdout{"*sits*\n"}
   }
   bark(dog:this) {
      C1.stdout{"arf!!\n"}
   }
}
main():intc {
   Dog.sit(dog!); // Declare a variable using the type in function argument
   dog.bark();
   a! = 1+2; // *COMPILE ERROR*, spaces are require before and after operators
   names-can-have-dashes! = true; // Able to name variables, functions and structs with dashes!
   return 0;
}
```
- **Function arguments** can be used to declare variables.
- **Spaces are required** before and after operators. Function, struct, enum and variable **names can have dashes**, like in Lisp.
- [Metamethods](/docs/meta#metafunctions-and-metamethods) can help you **implement printf-like functionality** easily.

## ‚úîÔ∏èFeatures of C With The Same Speed As C
- Cp1 outputs C codes with **zero run-time overhead**. It is as if you are using C in a different syntax and performance is just literally the same. Try the `cp1-compile` binary in the `bin` folder to see the output C codes.
- Loops in C (except for do-while) are available in Cp1 as a single, unified `loop` keyword.
- Even the `#ifdef` preprocessor macros have equivalent in Cp1 using the metaprogramming compile-time `if` statements.
